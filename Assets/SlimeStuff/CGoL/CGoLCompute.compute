// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Update

// Hash function www.cs.ubc.ca/~rbridson/docs/schechter-sca08-turbulence.pdf
uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float scaleToRange01(uint state)
{
    return state / 4294967295.0;
}

RWTexture2D<float4> displayTexture;
RWTexture2D<float4> processTexture;
float4 ALIVE;
float4 DEAD;
int width;
int height;
float deltaTime;
float time;

int rangeStart;
int rangeEnd;
int spawn;

[numthreads(8,8,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
    int sum = 0;
    for (int offsetX = -1; offsetX <= 1; offsetX++)
    {
        for (int offsetY = -1; offsetY <= 1; offsetY++)
        {
            int indexX = min(width - 1, max(id.x + offsetX, 0));
            int indexY = min(height - 1, max(id.y + offsetY, 0));
            sum += (int)displayTexture[int2(indexX, indexY)].x;
        }
    }
    if (sum < rangeStart || sum > rangeEnd)
    {
        processTexture[id.xy] = DEAD;
    }
    else if (sum = spawn)
    {
        processTexture[id.xy] = ALIVE;
    }
}

#pragma kernel Display

[numthreads(8,8,1)]
void Display (uint3 id: SV_DispatchThreadID)
{
    displayTexture[id.xy] = processTexture[id.xy];
}

#pragma kernel Initialize

[numthreads(8,8,1)]
void Initialize (uint3 id: SV_DispatchThreadID)
{
    displayTexture[id.xy] = ALIVE;
}
